# Ныряем в Git с разбега.


## Введение


Один из самых простых и быстрых способов взглянуть  на **Git** - пройти курс Яндекс.Практикума "Начало работы с Git". Суть изложена просто и понятно, почти все примеры легко выполняются. Сам не замечаешь, как всё получается. _Эх, если б не некоторые вольности с терминологией и исторические ляпы..._ Но мёда гораздо больше!!!

Можно, конечно, посмотреть разные видеокурсы или почитать вводные книжки, поискать в Интернете, наконец. Больше времени, меньше толка.

Ну а для серьёзного освоения - читайте Скотта Чакона "Git для профессионального программиста" или "*курите мануал*".


## Рабочий цикл

Установим программу как сумеем, лучше с официального сайта "git-scm.com".
Проверка: git version
В ответ должен появиться номер версии.

1. Создаём пустой каталог (директорию).
mkdir <название каталога>

2. Создаём репозиторий.
git init

Ежели нам чем-то не угодил *master*, можем назвать главную ветку по-другому, чаще всего *main*:
git init -b main

3. Представляемся - сообщаем наши имя (можно псевдоним) и электронную почту.
git config user.name "имя или псевдоним"
git config user.email "электронный-почтовый@ящик.где-то"

4. Пишем, правим, сочиняем...
тут используем знакомый редактор текста, картинок, музыки, видео, что там нам ещё в голову взбредёт

Для быстрой работы с **Git** крайне желательно освоить редактор всех времён и народов **Vim**. Также здорово помогают навыки работы в терминале или командной строке.

5. **Git** использует три каталога: рабочий (working), для передумывающих (stage area), он же индекс и хранилище (storage).

Р -> П: git add <файл>
П -> Х: git commit -m "поясняющий текст"

Далее с пункта 4 по кругу пока не надоест или пока всё не сделаешь.

Это *локальная* работа. Ну а если хочешь выложить свою нетленку в мир, или привлечь помощников, тогда придётся воспользоваться какой-нибудь площадкой (платформой), например GitHub, GitLab, Bitbucket, какой-нибудь ещё. Лучше всего купить хостинг и самому поднять сервер git. У GitLab было открытое предложение для этого.


## Взаимодействуем с GitHub (сейчас это уже Microsoft GitHub)

1. Регистируемся на сайте **https://github.com**. Пробиваемся через каптчу и подтверждение с почты.

2. Для общения с сайтом есть два способа: https и токены или ssh. SSH удобнее. В домашнем каталоге генерируем пару (приватный и публичный) ключей:
ssh-keygen -t ed25519 -C "электронный-почтовый@ящик.где-то"

Если не сработало, то попроще, послабее:
ssh-keygen -t rsa -b 4096 -C "электронный-почтовый@ящик.где-то"

Копируем содержимое файла "~/.ssh/id_ed25519.pub" или "~/.ssh/id_rsa.pub" на сайт github.com: Учётная запись -> Settings -> SSH and GPG keys -> New SSH key в поле Key. Также указываем какой-нибудь Title, например Personal key. В поле Key type должно быть "Authentication Key". Нажимаем на кнопочку "Add SSH key" и в терминале проверяем работу:
ssh -T git@github.com

3. Создаём на сайте репозиторий. Ищем вкладку Repository, жмакаем по кнопке New,
вводим Repository name, по желанию что-нибудь поясняем в Description. Теперь самое главное: тип репозитория собственный (private) или для всех подряд (public).  Осталось только подтвердить выбор: Create repository.

4. Связываем локальный и предоставленный GitHub репозитории:
git remote add origin git@github.com:<имя на github.com>/<название репозитория>

Название *origin* традиционно и **git** использует его по умолчанию, но может быть любым.
Проверяем: git remote -v. Должны появиться две похожие строки, одна со словом **fetch**, другая - **push**.

5. Передаём из локального репозитория в удалённый в первый раз:
git push -u origin master
Снова: если master не нравится, то пишем то, что писали в команде "git init -b ..." после ключа -b.

В дальнейшем можно проще: git push.

## Напоследок

Посмотреть что творится в репозитории можно командой **git status**.

Узнать историю коммитов поможет **git log**. Можно даже **git log --all**.

Успехов!!! Будьте здоровы и счастливы!!!

## Снова здорово!

### HEAD

Давайте заглянем в каталог ".git". В нём мы обнаружим файл "HEAD". А внутри файла ссылку вида: "ref: refs/heads/master". Ссылка указывает на последний сделанный коммит. Вообще своеобразная логика у Git: при каждом коммите вырастает новая голова, мало того, голову оказывается можно снять! Тьфу, ты, *отсоединить* (**detached**). И будет история изменений без головы, а голова где-то шляется. Продолжение может быть последует...

### git log

У этой команды, как и у большинства команд **git**, множество параметров (курите мануал, если что - его лекго достать командой **git help log**). Есть один очень экономный параметр: **--oneline**. Он кратко выведет информацию обо всех коммитах - только часть хэша и поясняющие сообщение. Пользуйтесь!

### git status

Что же под капотом у **Git**? Там целая файловая система!!! И все команды **Git** всего-навсего гоняют по ней файлики. Что-то копируют, что-то перемещают, что-то удаляют, на некоторые создают ссылки. И всё это фиксируют внутри своих служебных файлов, таких как "HEAD". Я наткнулся на один очень полезный файлик: ".git/info/exclude". В нём можно рассказать **Git**у, куда он свой нос совать не должен. Здорово помогло на macOS - избавился от надоедливых сообщений про неотслеживаемый файл ".DS_Store".

Нас интересуют три каталога - один видимый *working* - в нём мы творим и вытворяем всякое в надежде создать что-то прекрасное - и два невидимых: предварительный, он же *stage area*, он же *index*, он же *cashe* и почти постоянный - хранилище (storage). Предварительный спрашивает: "Ты уверен?" - "Да." А постоянный: "Ты **точно** уверен???" - "РАЗУМЕЕЕТСЯ!!! Сколько можно задавать глупые вопросы?!"

Команда **git status** и рассказывает нам где у нас хранятся файлики и их копии.
Состояние *untracked* - вижу файл, но ничего с ним не делаю.
Состояние *new* - появился новый файл, первый раз попал в "предварительные".
Состояние *modified* - что-то в файле поменялось по сравнению с "предварительным" или "постоянным".
Состояние *staged* - файлик в "постоянных" = "рабочий" = "предварительный".

Все, кроме *untracked* считаются *tracked*.

Бывает, что "рабочий" не равен "предварительный" и "предварительный" не равен "постоянный", ну или ещё пока нет "постоянного", тогда **git status** сообщает, что у файла два состояния: *modified* и *staged* одновременно.

Команда **git add** копирует "рабочий" в "предварительный".
Команда **git commit -m 'пояснение'** копирует "предварительный" в "постоянный".

Можно что-нибудь не то сделать с "рабочим", передумать и перезаписать его из "предварительного" с помощью **git restore**. Или из "постоянного" - вернуть какой-то из предыдущих коммитов. Но об этом потом.

А сейчас - ВСЁ.
Всех благ!
